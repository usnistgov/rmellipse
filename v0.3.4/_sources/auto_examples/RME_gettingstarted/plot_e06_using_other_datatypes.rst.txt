
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples\RME_gettingstarted\plot_e06_using_other_datatypes.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_RME_gettingstarted_plot_e06_using_other_datatypes.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_RME_gettingstarted_plot_e06_using_other_datatypes.py:


Using Arbitrary Data Types
==========================

The RME was built to work best with complex and float data-types inside
xarray DataArrays. However, the propagation algorithms are agnostic
to what's inside the DataArray so the basic functionality of wrapping a function
in a propagator will work regardless of what data type you put in them.

Basic propagation will work with arbitrary data types. However,
quality of life features like common grid handling, grouping by
categories, combining repeated measurements, calculating standard uncertainty,
and computing confidence intervals may not work depending on the
data type you use. You may have to recreate that functionality manually, and we
strongly recommend testing your data type with the propagator to ensure it
functions as you expect.

.. GENERATED FROM PYTHON SOURCE LINES 20-23

Setup
-----
First lets create a custom class and use it to create a RMEMeas object.

.. GENERATED FROM PYTHON SOURCE LINES 23-51

.. code-block:: Python

    import xarray as xr
    from rmellipse.uobjects import RMEMeas
    from rmellipse.propagators import RMEProp


    class myclass:
        def __init__(self, val):
            self.val = val

        def __str__(self):
            return 'my val is ' + str(self.val)

        def __repr__(self):
            return self.__str__()

        def __add__(self, o):
            newval = self.val + o.val
            return myclass(newval)


    nominal = xr.DataArray(myclass(2))
    perturbed = xr.DataArray(myclass(2) + myclass(0.1))

    meas = RMEMeas.from_nom('test', nominal)
    meas.add_umech('sample_meas', perturbed)
    print(meas)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    test with nominal: 
    <xarray.DataArray ()> Size: 8B
    array(my val is 2, dtype=object)




.. GENERATED FROM PYTHON SOURCE LINES 52-56

Propagation
-----------
Because our custom class can be added together, we can use a vectorized
propagator with them.

.. GENERATED FROM PYTHON SOURCE LINES 56-66

.. code-block:: Python

    myprop = RMEProp(sensitivity=True, vectorize=True)


    @myprop.propagate
    def add(x, y):
        return x + y


    print(add(meas, meas))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    add with nominal: 
    <xarray.DataArray ()> Size: 8B
    array(my val is 4, dtype=object)




.. GENERATED FROM PYTHON SOURCE LINES 67-71

Sometimes you may need to take the object out of the xarray so you can
operate on it or pass it through other functions.
In that case you just need to put it
back into a DataArray with the parameter locations before you output it.

.. GENERATED FROM PYTHON SOURCE LINES 71-87

.. code-block:: Python



    @myprop.propagate
    def add2(x, y):
        # pre-allocate an output
        out = xr.zeros_like(x)
        # take the custom classes out of the xarray object and operate on them
        new_vals = x.values + y.values
        # put them back in the DataArray we pre-allocated
        out.values = new_vals
        return out


    new_meas = add2(meas, meas)
    print(new_meas)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    add2 with nominal: 
    <xarray.DataArray ()> Size: 8B
    array(my val is 4, dtype=object)




.. GENERATED FROM PYTHON SOURCE LINES 88-90

Next we can convert our data type to a float so we can
use other built in features, like calculating standard uncertainty.

.. GENERATED FROM PYTHON SOURCE LINES 90-103

.. code-block:: Python



    @myprop.propagate
    def to_float(x):
        out = xr.zeros_like(x)
        out.values = [xi.val for xi in x.values]
        return out


    new_meas = to_float(new_meas)
    lin_unc, mc_un = new_meas.stdunc()
    print(new_meas)
    print(lin_unc)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    to_float with nominal: 
    <xarray.DataArray ()> Size: 8B
    array(4.)
    <xarray.DataArray ()> Size: 8B
    array(0.2)





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.088 seconds)


.. _sphx_glr_download_auto_examples_RME_gettingstarted_plot_e06_using_other_datatypes.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_e06_using_other_datatypes.ipynb <plot_e06_using_other_datatypes.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_e06_using_other_datatypes.py <plot_e06_using_other_datatypes.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_e06_using_other_datatypes.zip <plot_e06_using_other_datatypes.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
